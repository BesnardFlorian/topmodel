using TopModel.Core;
using TopModel.Utils;

namespace TopModel.Generator.Javascript;

public static class JavascriptUtils
{
    public static string GetPropertyTypeName(this IProperty property)
    {
        if (property is CompositionProperty cp)
        {
            return cp.Kind switch
            {
                "object" => cp.Composition.Name,
                "list" or "async-list" => $"{cp.Composition.Name}[]",
                string _ when cp.DomainKind!.TS!.Type.Contains("{class}") => cp.DomainKind.TS.Type.Replace("{class}", cp.Composition.Name),
                string _ => $"{cp.DomainKind.TS.Type}<{cp.Composition.Name}>"
            };
        }

        var fp = (IFieldProperty)property;

        if (fp.Domain.TS == null)
        {
            throw new ModelException(fp.Domain, $"Le type Typescript du domaine doit être renseigné.");
        }

        var fixedType = fp.Domain.TS.Type;

        var prop = fp is AliasProperty alp ? alp.Property : fp;

        if (prop is AssociationProperty ap && ap.Association.Reference && !ap.Property.Domain.AutoGeneratedValue)
        {
            fixedType = $"{ap.Association.Name}{ap.Property.Name}";
        }
        else if (((prop.Class?.Reference ?? false) || (prop.Class?.ReferenceValues.Any() ?? false)) && prop.Class.PrimaryKey?.Domain.AutoGeneratedValue != true)
        {
            if (prop == (prop.Class.PrimaryKey ?? prop.Class.Properties.OfType<IFieldProperty>().First()))
            {
                fixedType = $"{prop.Class.Name}{prop.Name}";
            }
        }

        if (fp is AliasProperty { ListDomain: not null } or AliasProperty { Property: AssociationProperty { Type: AssociationType.ManyToMany or AssociationType.OneToMany } })
        {
            fixedType += "[]";
        }

        return fixedType;
    }

    public static IEnumerable<(string Import, string Path)> GetImportsForProperties(IEnumerable<IProperty> properties, string currentModule)
    {
        return

            // Domaines de champs.
            properties.OfType<IFieldProperty>()
                .Where(p => p.Domain.TS?.Import != null)
                .Select(p => (p.Domain.TS!.Type, p.Domain.TS.Import!))

            // Domaines de compositions.
            .Concat(properties.OfType<CompositionProperty>()
                .Where(p => p.DomainKind?.TS?.Import != null)
                .Select(p => (p.DomainKind!.TS!.Type.Split('<').First(), p.DomainKind.TS.Import!)))

            // Types de références
            .Concat(properties
                .Select(p => p is AliasProperty alp ? alp.Property : p)
                .OfType<IFieldProperty>()
                .Select(prop => (prop, classe: prop is AssociationProperty ap ? ap.Association : prop.Class))
                .Where(pc => pc.prop.GetPropertyTypeName() != pc.prop.Domain.TS!.Type && pc.classe.Reference && (pc.classe.Reference || pc.classe.ReferenceValues.Any()) && pc.classe.PrimaryKey?.Domain.AutoGeneratedValue != true)
                .Select(pc =>
                {
                    var targetModule = pc.classe.Namespace.Module == currentModule
                       ? $"."
                       : $"{string.Join('/', currentModule.Split(".").Select(m => ".."))}/{string.Join('/', pc.classe.Namespace.Module.Split('.').Select(m => m.ToDashCase()))}";
                    return (Import: pc.prop.GetPropertyTypeName(), Path: $"{targetModule}/references");
                }))
            .Distinct();
    }

    public static IList<(string Import, string Path)> GroupAndSort(this IEnumerable<(string Import, string Path)> imports)
    {
        return imports
             .GroupBy(i => i.Path)
             .Select(i => (Import: string.Join(", ", i.Select(l => l.Import).OrderBy(x => x)), Path: i.Key))
             .OrderBy(i => i.Path.StartsWith(".") ? i.Path : $"...{i.Path}")
             .ToList();
    }
}
