using TopModel.Core;
using TopModel.Core.FileModel;
using TopModel.Utils;

namespace TopModel.Generator.Javascript;

/// <summary>
/// Paramètres pour la génération du Javascript.
/// </summary>
public class JavascriptConfig : GeneratorConfigBase
{
    /// <summary>
    /// Localisation du modèle, relative au répertoire de génération. Si non renseigné, aucun fichier ne sera généré.
    /// </summary>
    public string? ModelRootPath { get; set; }

    /// <summary>
    /// Localisation des ressources i18n, relative au répertoire de génération. Si non renseigné, aucun fichier ne sera généré.
    /// </summary>
    public string? ResourceRootPath { get; set; }

    /// <summary>
    /// Localisation des clients d'API, relative au répertoire de génération. Si non renseigné, aucun fichier ne sera généré.
    /// </summary>
    public string? ApiClientRootPath { get; set; }

    /// <summary>
    /// Chemin vers lequel sont créés les fichiers d'endpoints générés, relatif à la racine de l'API.
    /// </summary>
    public string ApiClientFilePath { get; set; } = "{module}";

    /// <summary>
    /// Chemin (ou alias commençant par '@') vers un 'fetch' personnalisé, relatif à la racine de l'API.
    /// </summary>
    public string FetchImportPath { get; set; } = "@focus4/core";

    /// <summary>
    /// Chemin (ou alias commençant par '@') vers le fichier 'domain', relatif à la racine du modèle.
    /// </summary>
    public string DomainImportPath { get; set; } = "../domains";

    /// <summary>
    /// Framework cible pour la génération.
    /// </summary>
    public TargetFramework TargetFramework { get; set; } = TargetFramework.FOCUS;

    /// <summary>
    /// Mode de génération (JS, JSON ou JSON Schema).
    /// </summary>
    public ResourceMode ResourceMode { get; set; }

    /// <summary>
    /// Mode de génération (JS, JSON ou JSON Schema).
    /// </summary>
    public bool TranslateReferences { get; set; } = true;

    /// <summary>
    /// Mode de génération des listes de références (définitions ou valeurs).
    /// </summary>
    public ReferenceMode ReferenceMode { get; set; } = ReferenceMode.DEFINITION;

    public string GetClassFileName(Class classe, string tag)
    {
        var rootPath = Path.Combine(OutputDirectory, ModelRootPath!.Replace("{tag}", tag.ToKebabCase())).Replace("\\", "/");
        return $"{rootPath}/{string.Join('/', classe.Namespace.Module.Split('.').Select(m => m.ToKebabCase()))}/{classe.Name.ToDashCase()}.ts";
    }

    public string GetEndpointsFileName(ModelFile file, string tag)
    {
        var fileSplit = file.Name.Split("/");
        var modulePath = Path.Combine(file.Module.Split('.').Select(m => m.ToKebabCase()).ToArray());
        var filePath = ApiClientFilePath.Replace("{module}", modulePath);
        var fileName = string.Join('_', fileSplit.Last().Split("_").Skip(fileSplit.Last().Contains('_') ? 1 : 0)).ToKebabCase();

        if (file.Options?.Endpoints?.FileName != null)
        {
            fileName = file.Options?.Endpoints?.FileName.ToKebabCase();
        }

        return Path.Combine(OutputDirectory, ApiClientRootPath!.Replace("{tag}", tag.ToKebabCase()), filePath, $"{fileName}.ts").Replace("\\", "/");
    }

    public List<(string Import, string Path)> GetEndpointImports(ModelFile file, string tag)
    {
        return file.Endpoints.SelectMany(e => e.ClassDependencies)
            .Select(dep => (
                Import: dep is { Source: IFieldProperty fp }
                    ? fp.GetPropertyTypeName().Replace("[]", string.Empty)
                    : dep.Classe.Name,
                Path: GetImportPathForClass(dep, tag)!))
            .Concat(file.Endpoints.SelectMany(d => d.DomainDependencies).Select(p => (Import: p.Domain.TS!.Type.ParseTemplate(p.Source).Split("<").First(), Path: p.Domain.TS.Import!.ParseTemplate(p.Source))))
            .Where(i => i.Path != null)
            .GroupAndSort();
    }

    public string? GetImportPathForClass(ClassDependency dep, string tag)
    {
        string target;
        if (dep.Source is IFieldProperty fp)
        {
            if (fp.GetPropertyTypeName() != fp.Domain.TS!.Type && dep.Classe.Reference && (dep.Classe.Reference || dep.Classe.ReferenceValues.Any()) && dep.Classe.PrimaryKey?.Domain.AutoGeneratedValue != true)
            {
                target = GetReferencesFileName(dep.Classe.Namespace.Module, tag);
            }
            else
            {
                return null;
            }
        }
        else
        {
            target = GetClassFileName(dep.Classe, tag);
        }

        var source = dep.Source switch
        {
            IProperty { Class: Class classe } => GetClassFileName(classe, tag),
            IProperty { Endpoint: Endpoint endpoint } => GetEndpointsFileName(endpoint.ModelFile, tag),
            Class classe => GetClassFileName(classe, tag),
            _ => null
        };

        if (source == null)
        {
            return null;
        }

        var path = Path.GetRelativePath(string.Join('/', source.Split('/').SkipLast(1)), target)[..^3].Replace("\\", "/");

        if (!path.StartsWith("."))
        {
            path = $"./{path}";
        }

        return path;
    }

    public string GetReferencesFileName(string module, string tag)
    {
        var rootPath = Path.Combine(OutputDirectory, ModelRootPath!.Replace("{tag}", tag.ToKebabCase())).Replace("\\", "/");
        return $"{rootPath}/{string.Join('/', module.Split('.').Select(m => m.ToKebabCase()))}/references.ts";
    }

    public string GetResourcesFilePath(string module, string tag)
    {
        return Path.Combine(OutputDirectory, ResourceRootPath!.Replace("{tag}", tag.ToKebabCase()), Path.Combine(module.Split(".").Select(part => part.ToKebabCase()).ToArray())) + (ResourceMode == ResourceMode.JS ? ".ts" : ".json");
    }
}
