using System.Globalization;
using TopModel.Core.FileModel;
using TopModel.Core.Model.Implementation;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;

namespace TopModel.Core.Loaders;

public class DomainLoader : ILoader<Domain>
{
    private readonly FileChecker _fileChecker;

    public DomainLoader(FileChecker fileChecker)
    {
        _fileChecker = fileChecker;
    }

    /// <inheritdoc cref="ILoader{T}.Load" />
    public Domain Load(Parser parser)
    {
        var domain = new Domain();

        parser.ConsumeMapping(prop =>
        {
            parser.TryConsume<Scalar>(out var value);

            switch (prop.Value)
            {
                case "name":
                    domain.Name = new LocatedString(value);
                    break;
                case "label":
                    domain.Label = value!.Value;
                    break;
                case "length":
                    domain.Length = Convert.ToInt32(decimal.Parse(value!.Value, CultureInfo.InvariantCulture));
                    break;
                case "scale":
                    domain.Scale = Convert.ToInt32(decimal.Parse(value!.Value, CultureInfo.InvariantCulture));
                    break;
                case "autoGeneratedValue":
                    domain.AutoGeneratedValue = value!.Value == "true";
                    break;
                case "bodyParam":
                    domain.BodyParam = value!.Value == "true";
                    break;
                case "asDomains":
                    parser.ConsumeMapping(prop =>
                    {
                        domain.AsDomainReferences[prop.Value] = new DomainReference(parser.Consume<Scalar>());
                    });
                    break;
                case "mediaType":
                    domain.MediaType = value!.Value;
                    break;
                default:
                    var implementation = new DomainImplementation();

                    parser.ConsumeMapping(prop =>
                    {
                        switch (prop.Value)
                        {
                            case "type":
                                implementation.Type = parser.Consume<Scalar>().Value;
                                break;
                            case "genericType":
                                implementation.GenericType = parser.Consume<Scalar>().Value;
                                break;
                            case "imports":
                                implementation.Imports = _fileChecker.Deserialize<List<string>>(parser);
                                break;
                            case "annotations":
                                implementation.Annotations = _fileChecker.Deserialize<List<TargetedText>>(parser);
                                break;
                            case "values":
                                ValueTemplate HandleValueTemplate()
                                {
                                    var valueTemplate = new ValueTemplate();

                                    if (parser.Current is MappingStart)
                                    {
                                        parser.ConsumeMapping(prop =>
                                        {
                                            switch (prop.Value)
                                            {
                                                case "value":
                                                    valueTemplate.Value = parser.Consume<Scalar>().Value;
                                                    break;
                                                case "imports":
                                                    parser.ConsumeSequence(() => valueTemplate.Imports.Add(parser.Consume<Scalar>().Value));
                                                    break;
                                            }
                                        });
                                    }
                                    else
                                    {
                                        valueTemplate.Value = parser.Consume<Scalar>().Value;
                                    }

                                    return valueTemplate;
                                }

                                parser.ConsumeMapping(prop =>
                                {
                                    switch (prop.Value)
                                    {
                                        case "template":
                                            implementation.ValueTemplates.Add(ValueTemplate.Default, HandleValueTemplate());
                                            break;
                                        case "overrides":
                                            parser.ConsumeMapping(prop => implementation.ValueTemplates.Add(prop.Value, HandleValueTemplate()));
                                            break;
                                    }
                                });
                                break;
                        }
                    });

                    domain.Implementations[prop.Value] = implementation;
                    break;
            }
        });

        return domain;
    }
}