using System.Globalization;
using TopModel.Core.FileModel;
using TopModel.Core.Model.Implementation;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;

namespace TopModel.Core.Loaders;

public class DomainLoader : ILoader<Domain>
{
    private readonly FileChecker _fileChecker;

    public DomainLoader(FileChecker fileChecker)
    {
        _fileChecker = fileChecker;
    }

    /// <inheritdoc cref="ILoader{T}.Load" />
    public Domain Load(Parser parser)
    {
        var domain = new Domain();

        parser.ConsumeMapping(() =>
        {
            var prop = parser.Consume<Scalar>().Value;
            parser.TryConsume<Scalar>(out var value);

            switch (prop)
            {
                case "name":
                    domain.Name = new LocatedString(value);
                    break;
                case "label":
                    domain.Label = value!.Value;
                    break;
                case "length":
                    domain.Length = Convert.ToInt32(decimal.Parse(value!.Value, CultureInfo.InvariantCulture));
                    break;
                case "scale":
                    domain.Scale = Convert.ToInt32(decimal.Parse(value!.Value, CultureInfo.InvariantCulture));
                    break;
                case "autoGeneratedValue":
                    domain.AutoGeneratedValue = value!.Value == "true";
                    break;
                case "bodyParam":
                    domain.BodyParam = value!.Value == "true";
                    break;
                case "asDomains":
                    parser.ConsumeMapping(() =>
                    {
                        domain.AsDomainReferences[parser.Consume<Scalar>().Value] = new DomainReference(parser.Consume<Scalar>());
                    });
                    break;
                case "mediaType":
                    domain.MediaType = value!.Value;
                    break;
                default:
                    var implementation = new DomainImplementation();

                    parser.ConsumeMapping(() =>
                    {
                        var prop = parser.Consume<Scalar>().Value;

                        switch (prop)
                        {
                            case "type":
                                implementation.Type = new DomainType();

                                if (parser.TryConsume<Scalar>(out var scalar))
                                {
                                    implementation.Type.Default = scalar.Value;
                                    implementation.Type.Composition = scalar.Value;
                                }
                                else
                                {
                                    implementation.Type = _fileChecker.Deserialize<DomainType>(parser);
                                }

                                implementation.Type.AsTransformed ??= implementation.Type.Default;
                                break;
                            case "imports":
                                implementation.Imports = _fileChecker.Deserialize<List<string>>(parser);
                                break;
                            case "annotations":
                                implementation.Annotations = _fileChecker.Deserialize<List<TargetedText>>(parser);
                                break;
                        }
                    });

                    domain.Implementations[prop] = implementation;
                    break;
            }
        });

        return domain;
    }
}